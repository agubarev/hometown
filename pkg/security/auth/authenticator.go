package auth

import (
	"bytes"
	"context"
	"crypto/rand"
	"crypto/rsa"
	"log"
	"net"
	"net/http"
	"strings"
	"time"

	"github.com/agubarev/hometown/pkg/client"
	"github.com/agubarev/hometown/pkg/group"
	"github.com/agubarev/hometown/pkg/security/password"
	"github.com/agubarev/hometown/pkg/token"
	"github.com/agubarev/hometown/pkg/user"
	"github.com/agubarev/hometown/pkg/util"
	"github.com/allegro/bigcache"
	"github.com/dgrijalva/jwt-go"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"go.uber.org/zap"
)

// Context holds metadata which describes authenticated session
type Context struct {
	Identity
	Domain
}

// Domain represents an accesspolicy domain
type Domain uint8

const (
	DGeneral Domain = 1 << iota
	DAdmin
)

func (d Domain) String() string {
	switch d {
	case DGeneral:
		return "general"
	case DAdmin:
		return "administrative"
	default:
		return "unrecognized domain"
	}
}

// ContextKey is a named context key type for this package
type ContextKey uint8

// context keys
const (
	CKAuthenticator ContextKey = iota
	CKUserManager
	CKUser
)

// Claims holds required JWT claims
type Claims struct {
	Identity Identity `json:"identity"`

	jwt.StandardClaims
}

// TokenPair contains access and refresh tokens which
// are returned back to the client upon successful authentication
type TokenPair struct {
	AccessToken  string           `json:"access_token"`
	RefreshToken RefreshTokenHash `json:"refresh_token,omitempty"`
}

// ClientCredentials represents client authentication credentials
type ClientCredentials struct {
	ClientID uuid.UUID  `json:"client_id"`
	Secret   token.Hash `json:"secret"`
}

// UserCredentials represents user authentication credentials
type UserCredentials struct {
	Username string `json:"username"`
	Password []byte `json:"password"`
}

type Options struct {
	AccessTokenTTL   time.Duration
	RefreshTokenTTL  time.Duration
	CompareIP        bool
	CompareUserAgent bool
}

func DefaultOptions() Options {
	return Options{
		AccessTokenTTL:   15 * time.Minute,
		RefreshTokenTTL:  24 * time.Hour,
		CompareIP:        false,
		CompareUserAgent: true,
	}
}

// RequestMetadata holds request information
type RequestMetadata struct {
	UserAgent string
	IP        net.IP
}

// NewRequestMetadata initializes RequestMetadata from a given http.Request
func NewRequestMetadata(r *http.Request) (meta *RequestMetadata) {
	// this is just a convenience for tests
	if r == nil {
		return &RequestMetadata{
			IP:        net.IPv4zero,
			UserAgent: "Test User-Agent",
		}
	}

	sip, _, err := net.SplitHostPort(r.RemoteAddr)
	if err != nil && err.Error() != "missing port in address" {
		log.Printf("NewRequestMetadata: net.SplitHostPort failed: %s", err)
		return meta
	}

	return &RequestMetadata{
		IP:        net.ParseIP(sip),
		UserAgent: r.UserAgent(),
	}
}

// SanitizeAndValidate performs basic trimming and validations
// TODO: consider preserving original username but still change case to lower
// NOTE: trimming passwords whitespace to prevent problems when people copy+paste
func (c *UserCredentials) SanitizeAndValidate() error {
	c.Username = strings.ToLower(strings.TrimSpace(c.Username))
	c.Password = bytes.TrimSpace(c.Password)

	if c.Username == "" {
		return ErrEmptyUsername
	}

	if len(c.Password) == 0 {
		return ErrEmptyPassword
	}

	return nil
}

// Authenticator represents an authenticator which is responsible
// for the user authentication and authorization
type Authenticator struct {
	opts       Options
	users      *user.Manager
	clients    *client.Manager
	backend    Backend
	privateKey *rsa.PrivateKey
	logger     *zap.Logger
}

// NewAuthenticator initializes a new authenticator
// NOTE: if private key is nil, then using an autogenerated key
func NewAuthenticator(
	pk *rsa.PrivateKey,
	users *user.Manager,
	clients *client.Manager,
	b Backend,
	opts Options,
) (*Authenticator, error) {
	if users == nil {
		return nil, ErrNilUserManager
	}

	// validating the supplied user manager
	if err := users.Validate(); err != nil {
		return nil, err
	}

	// if the private key is nil, then generating a temporary
	// key only for this instance
	if pk == nil {
		k, err := rsa.GenerateKey(rand.Reader, 2048)
		if err != nil {
			return nil, errors.Wrap(err, "failed to generate private key for authenticator")
		}

		pk = k
	}

	// using a default in-memory backend if nil is presented
	if b == nil {
		b = NewDefaultRegistryBackend()
	}

	// initializing new authenticator
	m := &Authenticator{
		users:      users,
		clients:    clients,
		opts:       opts,
		backend:    b,
		privateKey: pk,
	}

	return m, nil
}

// SetLogger sets an own logger
func (a *Authenticator) SetLogger(logger *zap.Logger) error {
	if logger != nil {
		logger = logger.Named("[authenticator]")
	}

	a.logger = logger

	return nil
}

// Logger returns own logger
func (a *Authenticator) Logger() *zap.Logger {
	if a.logger == nil {
		l, err := zap.NewDevelopment()
		if err != nil {
			panic(errors.Wrap(err, "failed to initialize authenticator logger"))
		}

		a.logger = l
	}

	return a.logger
}

func (a *Authenticator) UserManager() *user.Manager {
	if a.users == nil {
		panic(ErrNilUserManager)
	}

	return a.users
}

func (a *Authenticator) GroupManager() *group.Manager {
	return a.UserManager().GroupManager()
}

func (a *Authenticator) PasswordManager() password.Manager {
	return a.UserManager().PasswordManager()
}

func (a *Authenticator) TokenManager() *token.Manager {
	return a.UserManager().TokenManager()
}

// PrivateKey returns a private key (RSA) used by this manager
func (a *Authenticator) PrivateKey() (*rsa.PrivateKey, error) {
	if a.privateKey == nil {
		return nil, ErrNilPrivateKey
	}

	return a.privateKey, nil
}

// ParseToken validates and parses a JWT token and returns its claims
func (a *Authenticator) claimsFromToken(tok string) (claims Claims, err error) {
	// obtaining manager's private key
	pk, err := a.PrivateKey()
	if err != nil {
		return claims, ErrNilPrivateKey
	}

	// validating and parsing token
	t, err := jwt.ParseWithClaims(tok, &claims, func(t *jwt.Token) (interface{}, error) {
		// making sure that proper signing method is used
		if _, ok := t.Method.(*jwt.SigningMethodRSA); !ok {
			return nil, errors.New("invalid signing method")
		}

		return pk.Public(), nil
	})

	if err != nil {
		return claims, err
	}

	// validating a token on a time basis (i.e. expired, not eligible yet, etc...)
	if !t.Valid {
		return claims, ErrInvalidAccessToken
	}

	return claims, nil
}

// TODO take metadata into account when authenticating
func (a *Authenticator) AuthenticateClientBySecret(
	ctx context.Context,
	clientID uuid.UUID,
	secret []byte,
	meta *RequestMetadata,
) (
	c *client.Client,
	session *Session,
	signedToken string,
	err error,
) {
	// obtaining client
	c, err = a.clients.ClientByID(ctx, clientID)
	if err != nil {
		return nil, nil, "", errors.Wrapf(err, "failed to obtain client by id: %s", clientID)
	}

	// only enabled clients are allowed to be authenticated
	if !c.IsEnabled() {
		return nil, nil, "", ErrClientDisabled
	}

	// expired client also cannot be authenticated
	if c.IsExpired() {
		return nil, nil, "", ErrClientExpired
	}

	// obtaining client's secret(password)
	ok, err := a.clients.MatchSecret(ctx, clientID, secret)
	if err != nil {
		return nil, nil, "", errors.Wrapf(err, "failed to match client secret: %s", clientID)
	}

	// do secrets match?
	if !ok {
		return nil, nil, "", ErrClientSecretMismatch
	}

	// creating a new session for this client alone
	session, signedToken, err = a.CreateSession(
		ctx,
		c,
		NilIdentity,
		meta,
	)

	a.Logger().Debug("client authentication",
		zap.String("client_id", c.ID.String()),
		zap.String("client_name", c.Name),
		zap.String("session_id", session.ID.String()),
	)

	return c, session, signedToken, nil
}

func (a *Authenticator) ExchangeAuthorizationCode(
	ctx context.Context,
	code string,
	meta *RequestMetadata,
) (
	tpair TokenPair,
	err error,
) {
	tpair, err = a.backend.ExchangeCode(ctx, code)
	if err != nil {
		a.Logger().Error(
			"failed to exchange authorization code for token",
			zap.String("code", code),
			zap.Error(err),
		)

		if err == bigcache.ErrEntryNotFound {
			return tpair, ErrAuthorizationCodeNotFound
		}
	}

	return tpair, nil
}

// AuthenticateByPassword authenticates a user by username and password.
// each successful authentication generates a new access token and spawns
// a new session identified by that token's JTI (JWT ID).
// NOTE: the number of active sessions should be limited by a sensible amount
func (a *Authenticator) AuthenticateUserByPassword(
	ctx context.Context,
	username string,
	rawpass []byte,
	meta *RequestMetadata,
) (u user.User, err error) {
	// obtaining user
	u, err = a.UserManager().UserByUsername(ctx, username)
	if err != nil {
		return u, err
	}

	// setting default logger fields
	l := a.Logger().With(
		zap.String("user_id", u.ID.String()),
		zap.String("username", u.Username),
		zap.String("ip", meta.IP.String()),
		zap.String("user_agent", meta.UserAgent),
	)

	// before authentication, checking whether this user is suspended
	if u.IsSuspended {
		l.Debug(
			"authentication attempt by a suspended user (by password)",
			zap.Time("suspended_at", u.SuspendedAt),
			zap.Time("suspension_expires_at", u.SuspensionExpiresAt),
		)

		return u, ErrUserSuspended
	}

	// obtaining password manager
	pm := a.PasswordManager()

	// obtaining user's password
	userpass, err := pm.Get(ctx, password.NewOwner(password.OKUser, u.ID))
	if err != nil {
		if err == password.ErrPasswordNotFound {
			l.Debug("password not found", zap.Error(err))
		} else {
			l.Error("failed to obtain password", zap.Error(err))
		}

		return u, err
	}

	// comparing passwords
	if !userpass.Compare(rawpass) {
		l.Debug("wrong password")
		return u, ErrAuthenticationFailed
	}

	l.Debug("authenticated by password")

	return u, nil
}

func (a *Authenticator) AuthenticateUserByRefreshToken(
	ctx context.Context,
	c *client.Client,
	hash RefreshTokenHash,
	meta *RequestMetadata,
) (
	session *Session,
	tpair TokenPair,
	err error,
) {
	// declaring the initial default logger fields
	l := a.Logger().With(
		zap.String("ip", meta.IP.String()),
		zap.String("user_agent", meta.UserAgent),
	)

	// WARNING: refresh token is revoked by a deferred function in case of any error
	// first, obtain refresh token by hash
	rtok, err := a.RefreshTokenByHash(ctx, hash)
	if err != nil {
		return nil, tpair, errors.Wrap(err, "failed to authenticate user by refresh token")
	}

	// extending logger fields
	l = l.With(zap.String("rtok_id", rtok.ID.String()))

	// NOTE: this deferred function will revoke refresh token in case of any error
	defer func() {
		// TODO: revoke an actual refresh token if any of its previous versions are used
		switch err {
		case nil:
			// NOTE: do nothing if there was no error
		case ErrRefreshTokenExpired,
			ErrRefreshTokenRotated,
			ErrRefreshTokenRevoked:
			// if the refresh token is not active due to any of the listed errors,
			// then return, otherwise this refresh token must be revoked
			return
		default:
			// revoke refresh token in case of any error
			a.Logger().Warn(
				"revoking refresh token due to an error",
				zap.String("rtok_id", rtok.ID.String()),
				zap.String("reason", errors.Cause(err).Error()),
			)

			// NOTE: using error string as a reason
			if _err := a.RevokeRefreshToken(ctx, rtok.Hash, errors.Cause(err).Error()); _err != nil {
				a.Logger().Error(
					"failed to revoke refresh token",
					zap.String("rtok_id", rtok.ID.String()),
					zap.String("reason", err.Error()),
					zap.Error(errors.Wrap(_err, "failed to revoke refresh token (emergency)")),
				)
			}
		}
	}()

	// is refresh token active?
	if ok, err := rtok.IsActive(); !ok {
		l.Warn("authentication attempt by revoked refresh token")
		return nil, tpair, err
	}

	// checking whether this token was issuer for a user identity
	if rtok.Identity.Kind != IKUser {
		return nil, tpair, ErrIdentityMismatch
	}

	// checking whether there is an existing session attached to this refresh token
	session, err = a.SessionByID(ctx, rtok.LastSessionID)
	switch err {
	case nil:
		// WARNING: re-using existing session if it's active
		// NOTE: an expired session is also considered as revoked
		if session.IsRevoked() {
			// since this session has been revoked, then it makes
			// sense to also revoke its related refresh token
			return nil, tpair, ErrSessionRevoked
		}
	case ErrSessionNotFound:
		// session is not found, creating new session without
		// intermediary authorization code
		session, tpair, err = a.CreateSessionWithRefreshToken(
			ctx,
			&rtok,
			c,
			UserIdentity(rtok.Identity.ID),
			meta,
		)

		if err != nil {
			return nil, tpair, errors.Wrapf(
				err,
				"failed to create new session, authenticated by refresh token",
			)
		}
	}

	// obtaining associated user
	u, err := a.UserManager().UserByID(ctx, session.Identity.ID)
	if err != nil {
		return nil, tpair, errors.Wrap(err, "failed to obtain user associated with this session")
	}

	// extending logger fields
	l = a.Logger().With(
		zap.String("user_id", session.Identity.ID.String()),
		zap.String("username", u.Username),
	)

	// TODO apply middleware functions

	// before authentication, checking whether this user is suspended
	if u.IsSuspended {
		l.Debug(
			"authentication attempt by a suspended user (by refresh token)",
			zap.Time("suspended_at", u.SuspendedAt),
			zap.Time("suspension_expires_at", u.SuspensionExpiresAt),
		)

		// since this user is suspended, then it's safe to assume
		// that this token is a liability and a possible threat,
		// and... is asking to be deleted
		if err = a.backend.DeleteRefreshToken(ctx, rtok); err != nil {
			l.Error(
				"USER SUSPENDED: failed to delete refresh token",
				zap.Error(err),
			)

			return session, tpair, errors.Wrapf(err, "failed to delete refresh token: %s", rtok.ID)
		}

		return session, tpair, ErrUserSuspended
	}

	l.Debug("authenticated user by refresh token (rotated)")

	return session, tpair, nil
}

// TODO: considered whether this is a redundant function
func (a *Authenticator) RefreshTokenByHash(
	ctx context.Context,
	hash RefreshTokenHash,
) (
	rt RefreshToken,
	err error,
) {
	if err = hash.Validate(); err != nil {
		return rt, err
	}

	return a.backend.RefreshTokenByHash(ctx, hash)
}

// CreateSession creates a new session for a given owner within the specified realm
func (a *Authenticator) CreateSession(
	ctx context.Context,
	clnt *client.Client,
	ident Identity,
	meta *RequestMetadata,
) (
	session *Session,
	signedToken string,
	err error,
) {
	// obtaining private key
	pk, err := a.PrivateKey()
	if err != nil {
		return session, "", errors.Wrap(err, "failed to obtain private key")
	}

	// initializing new session
	session, err = NewSession(clnt, ident, meta, DefaultSessionTTL)
	if err != nil {
		return session, "", errors.Wrap(err, "failed to initialize new session")
	}

	// initializing new access token
	signedToken, err = NewAccessToken(pk, session.ID, ident, session.ExpireAt)
	if err != nil {
		return session, "", errors.Wrap(err, "failed to initialize new access token")
	}

	// adding session to the registry
	if err = a.backend.CreateSession(ctx, session); err != nil {
		return session, "", errors.Wrap(err, "failed to register new session")
	}

	return session, signedToken, nil
}

func (a *Authenticator) CreateSessionWithRefreshToken(
	ctx context.Context,
	oldToken *RefreshToken,
	clnt *client.Client,
	ident Identity,
	meta *RequestMetadata,
) (
	session *Session,
	tpair TokenPair,
	err error,
) {
	l := a.Logger()

	// aborting if given token is not active for whatever reason
	if oldToken != nil {
		if ok, err := oldToken.IsActive(); !ok {
			switch err = errors.Cause(err); err {
			case ErrRefreshTokenRotated:
				l.Warn(
					"authentication attempt with expired refresh token",
					zap.String("session_id", oldToken.ID.String()),
					zap.Error(err),
				)

				return nil, tpair, errors.Wrap(err, "given refresh token is expired")
			case ErrRefreshTokenExpired:
				l.Warn(
					"authentication attempt with expired refresh token",
					zap.String("session_id", oldToken.ID.String()),
					zap.Error(err),
				)

				return nil, tpair, errors.Wrap(err, "given refresh token is expired")
			default:
				l.Warn(
					"authentication attempt with inactive refresh token (unspecified cause)",
					zap.String("session_id", oldToken.ID.String()),
					zap.Error(err),
				)

				return nil, tpair, errors.Wrap(err, "given refresh token is not active")
			}
		}
	}

	// creating base session
	session, signedToken, err := a.CreateSession(ctx, clnt, ident, meta)
	if err != nil {
		return nil, tpair, errors.Wrap(err, "failed to create session")
	}

	// deferred safety measure: delete session if there was some error
	defer func() {
		if err != nil {
			l.Error(
				"failed to delete incomplete session",
				zap.String("session_id", session.ID.String()),
				zap.Error(err),
			)

			// deleting this session in case of any error at the end
			if _err := a.backend.DeleteSession(ctx, session); _err != nil {
				// wrapping error
				err = errors.Wrapf(err, "failed to delete incomplete session: %s", session.ID)
			}
		}
	}()

	var newToken RefreshToken

	// rotating if old refresh token is given
	if oldToken != nil {
		newToken, err = a.RotateRefreshToken(ctx, oldToken.Hash)
		if err != nil {
			return nil, tpair, errors.Wrap(err, "failed to rotate refresh token")
		}
	} else {
		// otherwise, initializing new refresh token
		newToken, err = NewRefreshToken(session.ID, clnt, ident, session.ExpireAt)
		if err != nil {
			return nil, tpair, errors.Wrap(err, "failed to initialize refresh token for new session")
		}

		// pushing refresh token to the backend
		if err = a.backend.CreateRefreshToken(ctx, newToken); err != nil {
			return nil, tpair, errors.Wrap(err, "failed to store refresh token to backend")
		}
	}

	// pairing tokens
	tpair = TokenPair{
		AccessToken:  signedToken,
		RefreshToken: newToken.Hash,
	}

	l.Debug(
		"created session with refresh token",
		zap.String("id", session.ID.String()),
		zap.String("ip", session.IP.String()),
		zap.String("identity_kind", session.Identity.Kind.String()),
		zap.String("identity_id", session.Identity.ID.String()),
	)

	return session, tpair, nil
}

func (a *Authenticator) CreateAuthorizationCode(
	ctx context.Context,
	challenge PKCEChallenge,
	tpair TokenPair,
) (code string, err error) {
	if err = challenge.Validate(); err != nil {
		return "", errors.Wrap(err, "PKCE challenge validation failed")
	}

	// generating authorization code
	authCode, err := util.NewCSPRNGHex(32)
	if err != nil {
		return "", errors.Wrap(err, "failed to generate authorization code")
	}

	// pushing authorization code coupled with a token pair
	if err = a.backend.CreateAuthorizationCode(ctx, authCode, challenge, tpair); err != nil {
		return "", errors.Wrap(err, "failed to store authorization code with token pair")
	}

	return authCode, nil
}

func (a *Authenticator) RotateRefreshToken(ctx context.Context, tokenHash RefreshTokenHash) (newToken RefreshToken, err error) {
	if err = tokenHash.Validate(); err != nil {
		return newToken, errors.Wrap(err, "current refresh token validation failed")
	}

	// updating the current token and initializing the new token
	_, err = a.backend.UpdateRefreshToken(ctx, tokenHash, func(ctx context.Context, currentToken RefreshToken) (RefreshToken, error) {
		// checking status of the actual refresh token (i.e.: expired, rotated, revoked?)
		if ok, err := currentToken.IsActive(); !ok {
			return currentToken, errors.Wrapf(err, "failed to rotate refresh token: %s", tokenHash)
		}

		// initializing a new refresh token
		newToken, err = NewRotatedRefreshToken(currentToken)
		if err != nil {
			return currentToken, errors.Wrap(err, "failed to initialize new refresh token")
		}

		// updating current token
		currentToken.RotatedAt = time.Now()
		currentToken.RotatedID = newToken.ID

		return currentToken, nil
	})

	if err != nil {
		return newToken, errors.Wrap(err, "failed to update current refresh token")
	}

	// pushing new refresh token to the backend
	if err = a.backend.CreateRefreshToken(ctx, newToken); err != nil {
		return newToken, errors.Wrap(err, "failed to create new rotated refresh token")
	}

	a.Logger().Debug(
		"rotated refresh token",
		zap.String("identity_kind", newToken.Identity.Kind.String()),
		zap.String("identity_id", newToken.Identity.ID.String()),
		zap.String("old_rtok_id", newToken.ParentID.String()),
		zap.String("new_rtok_id", newToken.ID.String()),
	)

	return newToken, nil
}

// RevokeSession revokes existing session instead of deleting,
// because previously issued access tokens are still out
// and can be used to re-generate a new session, thus it must
// be preserved until it eventually expires, and then deleted
// WARNING: session MUST NOT be deleted at least until it expires naturally
func (a *Authenticator) RevokeSession(ctx context.Context, session *Session, meta *RequestMetadata) (err error) {
	if session.IsRevoked() {
		return ErrSessionAlreadyRevoked
	}

	panic("not implemented")

	return nil
}

// SessionByID returns a session if it's found in the backend by its token string
func (a *Authenticator) SessionByID(ctx context.Context, jti uuid.UUID) (*Session, error) {
	return a.backend.SessionByID(ctx, jti)
}

func (a *Authenticator) RevokeRefreshToken(ctx context.Context, hash RefreshTokenHash, reason string) (err error) {
	rtok, err := a.RefreshTokenByHash(ctx, hash)
	if err != nil {
		return errors.Wrapf(err, "failed to obtain refresh token by hash: %s", hash.String())
	}

	logger := a.Logger().With(
		zap.String("rtok_id", rtok.ID.String()),
		zap.String("reason", reason),
	)

	// there is no need to revoke an already non-active refresh token
	if ok, err := rtok.IsActive(); !ok {
		return err
	}

	// a refresh token is considered as revoked if its revocation
	// timestamp is not zero
	rtok.RevokedAt = time.Now()

	// pushing to backend
	if err = a.backend.CreateRefreshToken(ctx, rtok); err != nil {
		logger.Warn("failed to revoke refresh token", zap.Error(err))
		return errors.Wrap(err, "failed to revoke refresh token")
	}

	logger.Debug("revoked refresh token")

	return nil
}
