package auth

import (
	"bytes"
	"context"
	"crypto/rand"
	"crypto/rsa"
	"fmt"
	"log"
	"net"
	"net/http"
	"time"

	"github.com/agubarev/hometown/pkg/client"
	"github.com/agubarev/hometown/pkg/group"
	"github.com/agubarev/hometown/pkg/security/password"
	"github.com/agubarev/hometown/pkg/token"
	"github.com/agubarev/hometown/pkg/user"
	"github.com/agubarev/hometown/pkg/util/bytearray"
	"github.com/dgrijalva/jwt-go"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"go.uber.org/zap"
)

// Context holds metadata which describes authenticated session
type Context struct {
	Identity
	Domain
}

// Domain represents an accesspolicy domain
type Domain uint8

const (
	DGeneral Domain = 1 << iota
	DAdmin
)

func (d Domain) String() string {
	switch d {
	case DGeneral:
		return "general"
	case DAdmin:
		return "administrative"
	default:
		return "unrecognized domain"
	}
}

// ContextKey is a named context key type for this package
type ContextKey uint8

// context keys
const (
	CKAuthenticator ContextKey = iota
	CKUserManager
	CKUser
)

// Claims holds required JWT claims
type Claims struct {
	Identity `json:"id"`

	jwt.StandardClaims
}

// TokenPair contains access and refresh tokens which
// are returned back to the client upon successful authentication
type TokenPair struct {
	AccessToken  string `json:"access_token"`
	RefreshToken Hash   `json:"refresh_token,omitempty"`
}

// ClientCredentials represents client authentication credentials
type ClientCredentials struct {
	ClientID uuid.UUID  `json:"client_id"`
	Secret   token.Hash `json:"secret"`
}

// UserCredentials represents user authentication credentials
type UserCredentials struct {
	Username string `json:"username"`
	Password []byte `json:"password"`
}

type Options struct {
	CompareIP        bool
	CompareUserAgent bool
}

func DefaultOptions() Options {
	return Options{
		CompareIP:        false,
		CompareUserAgent: true,
	}
}

// SanitizeAndValidate performs basic trimming and validations
// TODO: consider preserving original username but still change case to lower
// NOTE: trimming passwords whitespace to prevent problems when people copy+paste
func (c *UserCredentials) SanitizeAndValidate() error {
	c.Username.Trim()
	c.Username.ToLower()
	c.Password = bytes.TrimSpace(c.Password)

	if c.Username[0] == 0 {
		return ErrEmptyUsername
	}

	bytes.Fields()

	if len(c.Password) == 0 {
		return ErrEmptyPassword
	}

	return nil
}

// RequestMetadata holds request information
type RequestMetadata struct {
	UserAgent string
	IP        user.IPAddr
}

// NewRequestMetadata initializes RequestMetadata from a given http.Request
func NewRequestMetadata(r *http.Request) (meta RequestMetadata) {
	// this is just a convenience for tests
	if r == nil {
		return RequestMetadata{
			IP:        user.IPAddr{},
			UserAgent: bytearray.NewByteString32("Test User-Agent"),
		}
	}

	sip, _, err := net.SplitHostPort(r.RemoteAddr)
	if err != nil && err.Error() != "missing port in address" {
		log.Printf("NewRequestMetadata: net.SplitHostPort failed: %s", err)
		return meta
	}

	return RequestMetadata{
		IP:        user.NewIPAddrFromString(net.ParseIP(sip).String()),
		UserAgent: bytearray.NewByteString32(r.UserAgent()),
	}
}

// Authenticator represents an authenticator which is responsible
// for the user authentication and authorization
type Authenticator struct {
	AccessTokenTTL  time.Duration
	RefreshTokenTTL time.Duration

	opts       Options
	users      *user.Manager
	clients    *client.Manager
	backend    Backend
	privateKey *rsa.PrivateKey
	logger     *zap.Logger
}

// NewAuthenticator initializes a new authenticator
// NOTE: if private key is nil, then using an autogenerated key
func NewAuthenticator(pk *rsa.PrivateKey, users *user.Manager, clients *client.Manager, b Backend, opts Options) (*Authenticator, error) {
	if users == nil {
		return nil, ErrNilUserManager
	}

	// validating the supplied user manager
	if err := users.Validate(); err != nil {
		return nil, err
	}

	// if the private key is nil, then generating a temporary
	// key only for this instance
	if pk == nil {
		k, err := rsa.GenerateKey(rand.Reader, 2048)
		if err != nil {
			return nil, errors.Wrap(err, "failed to generate private key for authenticator")
		}

		pk = k
	}

	// using a default in-memory backend if nil is presented
	if b == nil {
		b = NewDefaultRegistryBackend()
	}

	// initializing new authenticator
	m := &Authenticator{
		AccessTokenTTL:  15 * time.Minute,
		RefreshTokenTTL: 24 * time.Hour,
		users:           users,
		clients:         clients,
		opts:            opts,
		backend:         b,
		privateKey:      pk,
	}

	return m, nil
}

// SetLogger sets an own logger
func (a *Authenticator) SetLogger(logger *zap.Logger) error {
	if logger != nil {
		logger = logger.Named("[AUTHENTICATOR]")
	}

	a.logger = logger

	return nil
}

// Logger returns own logger
func (a *Authenticator) Logger() *zap.Logger {
	if a.logger == nil {
		l, err := zap.NewDevelopment()
		if err != nil {
			panic(fmt.Errorf("failed to initialize authenticator logger: %s", err))
		}

		a.logger = l
	}

	return a.logger
}

func (a *Authenticator) UserManager() *user.Manager {
	if a.users == nil {
		panic(ErrNilUserManager)
	}

	return a.users
}

func (a *Authenticator) GroupManager() *group.Manager {
	return a.UserManager().GroupManager()
}

func (a *Authenticator) PasswordManager() password.Manager {
	return a.UserManager().PasswordManager()
}

func (a *Authenticator) TokenManager() *token.Manager {
	return a.UserManager().TokenManager()
}

// PrivateKey returns a private key (RSA) used by this manager
func (a *Authenticator) PrivateKey() (*rsa.PrivateKey, error) {
	if a.privateKey == nil {
		return nil, ErrNilPrivateKey
	}

	return a.privateKey, nil
}

// AuthenticateByCredentials authenticates a user by a given username and password
// each successful authentication generates a new access token and spawns
// a new session identified by that token's JTI (JWT ID).
// NOTE: the number of active sessions should be limited by a sensible amount
func (a *Authenticator) AuthenticateByCredentials(ctx context.Context, username string, rawpass []byte, meta *RequestMetadata) (u user.User, err error) {
	u, err = a.UserManager().UserByUsername(ctx, username)
	if err != nil {
		return u, err
	}

	// obtaining logger
	l := a.Logger().With(
		zap.String("user_id", u.ID.String()),
		zap.String("username", u.Username.String()),
		zap.String("ip", meta.IP.StringIPv4()),
		zap.String("user_agent", meta.UserAgent.String()),
	)

	// before authentication, checking whether this user is suspended
	if u.IsSuspended {
		l.Debug(
			"suspended user signin attempt",
			zap.Time("suspended_at", u.SuspendedAt.Time()),
			zap.Time("suspension_expires_at", u.SuspensionExpiresAt.Time()),
		)

		return u, ErrUserSuspended
	}

	// obtaining password manager
	pm := a.PasswordManager()

	// obtaining user's password
	userpass, err := pm.Get(ctx, password.OKUser, u.ID)
	if err != nil {
		if err == password.ErrPasswordNotFound {
			l.Debug("password not found", zap.Error(err))
		} else {
			l.Warn("failed to obtain password", zap.Error(err))
		}

		return u, err
	}

	// comparing passwords
	if !userpass.Compare(rawpass) {
		l.Debug("wrong password signin attempt")
		return u, ErrAuthenticationFailed
	}

	l.Debug("authenticated by credentials",
		zap.String("username", username.String()),
		zap.String("ip", meta.IP.StringIPv4()),
		zap.String("user_agent", meta.UserAgent.String()),
	)

	return u, nil
}

// AuthenticateByRefreshToken authenticates a user by a given refresh token
func (a *Authenticator) AuthenticateByRefreshToken(ctx context.Context, hash Hash, meta *RequestMetadata) (s *Session, err error) {
	// first, obtain refresh token by given hash
	rt, err := a.RefreshTokenByHash(ctx, hash)
	if err != nil {
		return nil, errors.Wrap(err, "authentication by refresh token failed")
	}

	// obtaining logger
	l := a.Logger().With(
		zap.Uint32("user_id", u.ID),
		zap.String("username", u.Username.String()),
		zap.String("ip", meta.IP.StringIPv4()),
		zap.String("user_agent", meta.UserAgent.String()),
	)

	// comparing IPs
	if a.opts.CompareIP {
		// TODO implement a more flexible way instead of comparing just strings
		if payload.IP != meta.IP {
			// IPs don't match, thus deleting this refresh token
			// to prevent any further use (safety first)
			if err = tm.Delete(ctx, t); err != nil {
				l.Warn("IPAddr MISMATCH: failed to delete refresh token", zap.Error(err), zap.String("token", t.Hash.String()))
				return u, fmt.Errorf("failed to delete refresh token: %s", t.Hash)
			}

			return u, ErrIPAddrMismatch
		}
	}

	// comparing User-Agent strings
	if a.opts.CompareUserAgent {
		if payload.UserAgent != meta.UserAgent {
			// given user agent doesn't match to what's saved in the session
			// deleting session because it could've been exposed (safety first)
			if err = tm.Delete(ctx, t); err != nil {
				l.Warn("USER-AGENT MISMATCH: failed to delete refresh token", zap.Error(err), zap.String("token", t.Hash.String()))
				return u, fmt.Errorf("failed to delete refresh token: %s", t.Hash)
			}
		}
	}

	// before authentication, checking whether this user is suspended
	if u.IsSuspended {
		l.Debug(
			"suspended user signin attempt (via refresh token)",
			zap.Time("suspended_at", u.SuspendedAt.Time()),
			zap.Time("suspension_expires_at", u.SuspensionExpiresAt.Time()),
		)

		// since this user is suspended, then it's safe to assume
		// that this token is a liability and a possible threat,
		// and... is asking to be deleted
		if err = tm.Delete(ctx, t); err != nil {
			l.Warn("USER SUSPENDED: failed to delete refresh token", zap.Error(err), zap.String("token", t.Hash))
			return u, fmt.Errorf("failed to delete refresh token: %s", t.Hash)
		}

		return u, ErrUserSuspended
	}

	l.Debug("authenticated by refresh token")

	return u, nil
}

func (a *Authenticator) RefreshTokenByHash(ctx context.Context, hash Hash) (rt RefreshToken, err error) {
	if err = hash.Validate(); err != nil {
		return rt, err
	}

	return a.backend.RefreshTokenByHash(ctx, hash)
}

// DestroySession destroys session by token, and as a given user
func (a *Authenticator) DestroySession(ctx context.Context, s *Session, meta *RequestMetadata) error {
	if s == nil {
		return ErrNilSession
	}

	// verifying whether this session belongs to this revoker
	if s.UserID != destroyedByID {
		return ErrIdentityMismatch
	}

	if s.UserAgent != meta.UserAgent {
		return ErrUserAgentMismatch
	}

	if s.IP != meta.IP {
		return ErrIPAddrMismatch
	}

	// obtaining refresh token
	rtok, err := tm.Get(ctx, s.RefreshToken)
	if err != nil {
		return err
	}

	// deleting refresh token
	err = tm.Delete(ctx, rtok)
	if err != nil {
		return err
	}

	// verifying refresh token ownership

	// revoking a corresponding accesspolicy token
	err = a.RevokeAccessToken(s.JTI, s.ExpireAt)
	if err != nil {
		return err
	}

	return errors.Wrap(a.backend.DeleteSession(s), "failed to delete session from the backend")
}

// GenerateAccessToken generates accesspolicy token for a given user
// WARNING: deprecated
// WARNING: deprecated
// WARNING: deprecated
func (a *Authenticator) GenerateAccessToken(ctx context.Context, realm string, ident Identity) (signedString string, jti uuid.UUID, err error) {
	if ident.ID == uuid.Nil {
		return signedString, uuid.Nil, ErrInvalidIdentityID
	}

	// obtaining private key
	pk, err := a.PrivateKey()
	if err != nil {
		return signedString, jti, errors.Wrap(err, "failed to obtain private key")
	}

	// token id
	jti = uuid.New()

	// generating and signing a new token
	atok := jwt.NewWithClaims(jwt.SigningMethodRS256, Claims{
		Identity: ident,
		StandardClaims: jwt.StandardClaims{
			Issuer:    realm,
			IssuedAt:  time.Now().Unix(),
			ExpiresAt: time.Now().Add(a.AccessTokenTTL).Unix(),
			Id:        jti.String(),
		},
	})

	// creating an accesspolicy token
	signedString, err = atok.SignedString(pk)
	if err != nil {
		return signedString, jti, fmt.Errorf("failed to obtain a signed token string: %s", err)
	}

	return signedString, jti, nil
}

func (a *Authenticator) CreateSession(ctx context.Context, realm string, o Owner, meta RequestMetadata) (s *Session, signedToken string, err error) {
	if o.Identity.ID == uuid.Nil {
		return nil, "", ErrInvalidIdentityID
	}

	// obtaining private key
	pk, err := a.PrivateKey()
	if err != nil {
		return nil, "", errors.Wrap(err, "failed to obtain private key")
	}

	// TODO: add PKCE (use Token package, 1 checkin, 1 min expiry)
	// TODO: store new access(+refresh) token inside Token payload

	s, err = NewSession(o, meta, DefaultSessionTTL)
	if err != nil {
		return nil, "", errors.Wrap(err, "failed to initialize new session")
	}

	atok, err := NewAccessToken(ctx, pk, s.ID, realm, o, s.ExpireAt)

	// adding session to the registry
	if err = a.RegisterSession(s); err != nil {
		return s, "", errors.Wrap(err, "failed to register new session")
	}

	return s, signedToken, nil
}

// ParseToken validates and parses a JWT token and returns its claims
func (a *Authenticator) claimsFromToken(tok string) (claims Claims, err error) {
	// obtaining manager's private key
	pk, err := a.PrivateKey()
	if err != nil {
		return claims, ErrNilPrivateKey
	}

	// validating and parsing token
	t, err := jwt.ParseWithClaims(tok, &claims, func(t *jwt.Token) (interface{}, error) {
		// making sure that proper signing method is used
		if _, ok := t.Method.(*jwt.SigningMethodRSA); !ok {
			return nil, fmt.Errorf("invalid signing method")
		}

		return pk.Public(), nil
	})

	if err != nil {
		return claims, err
	}

	// validating a token on a time basis (i.e. expired, not eligible yet)
	if !t.Valid {
		return claims, ErrInvalidAccessToken
	}

	return claims, nil
}

func (a *Authenticator) RegisterSession(s *Session) (err error) {
	if err = s.Validate(); err != nil {
		return err
	}

	return a.backend.UpsertSession(s)
}

// SessionByID returns a session if it's found in the backend
// by its token string
func (a *Authenticator) SessionByID(ctx context.Context, jti uuid.UUID) (Session, error) {
	return a.backend.SessionByID(ctx, jti)
}
