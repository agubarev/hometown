package auth

import (
	"bytes"
	"context"
	"crypto/rand"
	"crypto/rsa"
	"log"
	"net"
	"net/http"
	"strings"
	"time"

	"github.com/agubarev/hometown/pkg/client"
	"github.com/agubarev/hometown/pkg/group"
	"github.com/agubarev/hometown/pkg/security/password"
	"github.com/agubarev/hometown/pkg/token"
	"github.com/agubarev/hometown/pkg/user"
	"github.com/agubarev/hometown/pkg/util"
	"github.com/allegro/bigcache"
	"github.com/dgrijalva/jwt-go"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"go.uber.org/zap"
)

// Context holds metadata which describes authenticated session
type Context struct {
	Identity
	Domain
}

// Domain represents an accesspolicy domain
type Domain uint8

const (
	DGeneral Domain = 1 << iota
	DAdmin
)

func (d Domain) String() string {
	switch d {
	case DGeneral:
		return "general"
	case DAdmin:
		return "administrative"
	default:
		return "unrecognized domain"
	}
}

// ContextKey is a named context key type for this package
type ContextKey uint8

// context keys
const (
	CKAuthenticator ContextKey = iota
	CKUserManager
	CKUser
)

// Claims holds required JWT claims
type Claims struct {
	Identity Identity `json:"identity"`

	jwt.StandardClaims
}

// TokenPair contains access and refresh tokens which
// are returned back to the client upon successful authentication
type TokenPair struct {
	AccessToken  string `json:"access_token"`
	RefreshToken Hash   `json:"refresh_token,omitempty"`
}

// ClientCredentials represents client authentication credentials
type ClientCredentials struct {
	ClientID uuid.UUID  `json:"client_id"`
	Secret   token.Hash `json:"secret"`
}

// UserCredentials represents user authentication credentials
type UserCredentials struct {
	Username string `json:"username"`
	Password []byte `json:"password"`
}

type Options struct {
	AccessTokenTTL   time.Duration
	RefreshTokenTTL  time.Duration
	CompareIP        bool
	CompareUserAgent bool
}

func DefaultOptions() Options {
	return Options{
		AccessTokenTTL:   15 * time.Minute,
		RefreshTokenTTL:  24 * time.Hour,
		CompareIP:        false,
		CompareUserAgent: true,
	}
}

// SanitizeAndValidate performs basic trimming and validations
// TODO: consider preserving original username but still change case to lower
// NOTE: trimming passwords whitespace to prevent problems when people copy+paste
func (c *UserCredentials) SanitizeAndValidate() error {
	c.Username = strings.ToLower(strings.TrimSpace(c.Username))
	c.Password = bytes.TrimSpace(c.Password)

	if c.Username == "" {
		return ErrEmptyUsername
	}

	if len(c.Password) == 0 {
		return ErrEmptyPassword
	}

	return nil
}

// RequestMetadata holds request information
type RequestMetadata struct {
	UserAgent string
	IP        net.IP
}

// NewRequestMetadata initializes RequestMetadata from a given http.Request
func NewRequestMetadata(r *http.Request) (meta RequestMetadata) {
	// this is just a convenience for tests
	if r == nil {
		return RequestMetadata{
			IP:        net.IPv4zero,
			UserAgent: "Test User-Agent",
		}
	}

	sip, _, err := net.SplitHostPort(r.RemoteAddr)
	if err != nil && err.Error() != "missing port in address" {
		log.Printf("NewRequestMetadata: net.SplitHostPort failed: %s", err)
		return meta
	}

	return RequestMetadata{
		IP:        net.ParseIP(sip),
		UserAgent: r.UserAgent(),
	}
}

// Authenticator represents an authenticator which is responsible
// for the user authentication and authorization
type Authenticator struct {
	opts       Options
	users      *user.Manager
	clients    *client.Manager
	backend    Backend
	privateKey *rsa.PrivateKey
	logger     *zap.Logger
}

// NewAuthenticator initializes a new authenticator
// NOTE: if private key is nil, then using an autogenerated key
func NewAuthenticator(
	pk *rsa.PrivateKey,
	users *user.Manager,
	clients *client.Manager,
	b Backend,
	opts Options,
) (*Authenticator, error) {
	if users == nil {
		return nil, ErrNilUserManager
	}

	// validating the supplied user manager
	if err := users.Validate(); err != nil {
		return nil, err
	}

	// if the private key is nil, then generating a temporary
	// key only for this instance
	if pk == nil {
		k, err := rsa.GenerateKey(rand.Reader, 2048)
		if err != nil {
			return nil, errors.Wrap(err, "failed to generate private key for authenticator")
		}

		pk = k
	}

	// using a default in-memory backend if nil is presented
	if b == nil {
		b = NewDefaultRegistryBackend()
	}

	// initializing new authenticator
	m := &Authenticator{
		users:      users,
		clients:    clients,
		opts:       opts,
		backend:    b,
		privateKey: pk,
	}

	return m, nil
}

// SetLogger sets an own logger
func (a *Authenticator) SetLogger(logger *zap.Logger) error {
	if logger != nil {
		logger = logger.Named("[AUTHENTICATOR]")
	}

	a.logger = logger

	return nil
}

// Logger returns own logger
func (a *Authenticator) Logger() *zap.Logger {
	if a.logger == nil {
		l, err := zap.NewDevelopment()
		if err != nil {
			panic(errors.Wrap(err, "failed to initialize authenticator logger"))
		}

		a.logger = l
	}

	return a.logger
}

func (a *Authenticator) UserManager() *user.Manager {
	if a.users == nil {
		panic(ErrNilUserManager)
	}

	return a.users
}

func (a *Authenticator) GroupManager() *group.Manager {
	return a.UserManager().GroupManager()
}

func (a *Authenticator) PasswordManager() password.Manager {
	return a.UserManager().PasswordManager()
}

func (a *Authenticator) TokenManager() *token.Manager {
	return a.UserManager().TokenManager()
}

// PrivateKey returns a private key (RSA) used by this manager
func (a *Authenticator) PrivateKey() (*rsa.PrivateKey, error) {
	if a.privateKey == nil {
		return nil, ErrNilPrivateKey
	}

	return a.privateKey, nil
}

// ParseToken validates and parses a JWT token and returns its claims
func (a *Authenticator) claimsFromToken(tok string) (claims Claims, err error) {
	// obtaining manager's private key
	pk, err := a.PrivateKey()
	if err != nil {
		return claims, ErrNilPrivateKey
	}

	// validating and parsing token
	t, err := jwt.ParseWithClaims(tok, &claims, func(t *jwt.Token) (interface{}, error) {
		// making sure that proper signing method is used
		if _, ok := t.Method.(*jwt.SigningMethodRSA); !ok {
			return nil, errors.New("invalid signing method")
		}

		return pk.Public(), nil
	})

	if err != nil {
		return claims, err
	}

	// validating a token on a time basis (i.e. expired, not eligible yet, etc...)
	if !t.Valid {
		return claims, ErrInvalidAccessToken
	}

	return claims, nil
}

// TODO take metadata into account when authenticating
func (a *Authenticator) AuthenticateClientBySecret(
	ctx context.Context,
	clientID uuid.UUID,
	secret []byte,
	meta *RequestMetadata,
) (c *client.Client, authCode string, err error) {
	// obtaining client
	c, err = a.clients.ClientByID(ctx, clientID)
	if err != nil {
		return nil, "", errors.Wrapf(err, "failed to obtain client by id: %s", clientID)
	}

	// only enabled clients are allowed to be authenticated
	if !c.IsEnabled() {
		return nil, "", ErrClientDisabled
	}

	// expired client also cannot be authenticated
	if c.IsExpired() {
		return nil, "", ErrClientExpired
	}

	// obtaining client's secret(password)
	ok, err := a.clients.MatchSecret(ctx, clientID, secret)
	if err != nil {
		return nil, "", errors.Wrapf(err, "failed to match client secret: %s", clientID)
	}

	// do secrets match?
	if !ok {
		return nil, "", ErrClientSecretMismatch
	}

	// creating a new session for this client alone
	s, err, authCode := a.CreateSession(
		ctx,
		"hometown",
		c,
		NilIdentity,
		meta,
	)

	a.Logger().Debug("client authentication",
		zap.String("client_id", c.ID.String()),
		zap.String("client_name", c.Name),
		zap.String("session_id", s.ID.String()),
	)

	return c, authCode, nil
}

func (a *Authenticator) ExchangeAuthorizationCode(
	ctx context.Context,
	code string,
	meta *RequestMetadata,
) (
	signedToken string,
	err error,
) {
	signedToken, err = a.backend.ExchangeCode(ctx, code)
	if err != nil {
		a.Logger().Error(
			"failed to exchange authorization code for token",
			zap.String("code", code),
			zap.Error(err),
		)

		if err == bigcache.ErrEntryNotFound {
			return "", ErrAuthorizationCodeNotFound
		}
	}

	return signedToken, nil
}

// AuthenticateByPassword authenticates a user by username and password.
// each successful authentication generates a new access token and spawns
// a new session identified by that token's JTI (JWT ID).
// NOTE: the number of active sessions should be limited by a sensible amount
func (a *Authenticator) AuthenticateUserByPassword(
	ctx context.Context,
	username string,
	rawpass []byte,
	meta *RequestMetadata,
) (u user.User, err error) {
	// obtaining user
	u, err = a.UserManager().UserByUsername(ctx, username)
	if err != nil {
		return u, err
	}

	// setting default logger fields
	l := a.Logger().With(
		zap.String("user_id", u.ID.String()),
		zap.String("username", u.Username),
		zap.String("ip", meta.IP.String()),
		zap.String("user_agent", meta.UserAgent),
	)

	// before authentication, checking whether this user is suspended
	if u.IsSuspended {
		l.Debug(
			"suspended user signin attempt",
			zap.Time("suspended_at", u.SuspendedAt.Time()),
			zap.Time("suspension_expires_at", u.SuspensionExpiresAt.Time()),
		)

		return u, ErrUserSuspended
	}

	// obtaining password manager
	pm := a.PasswordManager()

	// obtaining user's password
	userpass, err := pm.Get(ctx, password.NewOwner(password.OKUser, u.ID))
	if err != nil {
		if err == password.ErrPasswordNotFound {
			l.Debug("password not found", zap.Error(err))
		} else {
			l.Error("failed to obtain password", zap.Error(err))
		}

		return u, err
	}

	// comparing passwords
	if !userpass.Compare(rawpass) {
		l.Debug("wrong password")
		return u, ErrAuthenticationFailed
	}

	l.Debug("authenticated by password")

	return u, nil
}

func (a *Authenticator) AuthenticateUserByRefreshToken(
	ctx context.Context,
	c *client.Client,
	hash Hash,
	meta *RequestMetadata,
) (
	session *Session,
	tpair TokenPair,
	err error,
) {
	// first, obtain refresh token by hash
	rtok, err := a.RefreshTokenByHash(ctx, hash)
	if err != nil {
		return nil, tpair, errors.Wrap(err, "failed to authenticate user by refresh token")
	}

	// security measure
	defer func() {
		if err != nil {
			// revoke refresh token in case of any error
			// TODO: add revocation reason
			a.Logger().Warn(
				"revoking refresh token due to an error",
				zap.String("rtok_id", rtok.ID.String()),
				zap.String("reason", err.Error()),
			)

			if _err := a.RevokeRefreshToken(ctx, rtok, err.Error()); _err != nil {
				a.Logger().Error(
					"failed to revoke refresh token",
					zap.String("rtok_id", rtok.ID.String()),
					zap.String("reason", err.Error()),
					zap.Error(errors.Wrap(_err, "failed to revoke refresh token (emergency)")),
				)

			}
		}
	}()

	// checking whether this token was issuer for a user identity
	if rtok.Identity.Kind != IKUser {
		return nil, tpair, ErrIdentityMismatch
	}

	// has refresh token expired?
	if rtok.IsExpired() {
		return nil, tpair, ErrRefreshTokenExpired
	}

	// checking whether there is an existing session attached to this refresh token
	session, err = a.SessionByID(ctx, rtok.LastSessionID)
	switch err {
	case nil:
		// session is found, but has it been revoked?
		// NOTE: an expired session is also considered as revoked
		if session.IsRevoked() {
			// since this session has been revoked, then it makes
			// sense to also revoke its related refresh token
			return nil, tpair, ErrSessionRevoked
		}
	case ErrSessionNotFound:
		// session is not found, creating new session directly,
		// without an intermediary authorization code
		session, tpair, _, err := a.CreateSession(
			ctx,
			"hometown",
			c,
			UserIdentity(rtok.Identity.ID),
			0,
			meta,
		)

		if err != nil {
			return nil, tpair, errors.Wrapf(
				err,
				"failed to create new session, authenticated by refresh token",
			)
		}
	}

	// obtaining associated user
	u, err := a.UserManager().UserByID(ctx, session.Identity.ID)
	if err != nil {
		return nil, tpair, errors.Wrap(err, "failed to obtain user associated with this session")
	}

	// declaring default logger fields
	l := a.Logger().With(
		zap.String("user_id", session.Identity.ID.String()),
		zap.String("username", u.Username),
		zap.String("ip", meta.IP.String()),
		zap.String("user_agent", meta.UserAgent),
	)

	// TODO apply middleware functions

	// before authentication, checking whether this user is suspended
	if u.IsSuspended {
		l.Debug(
			"suspended user signin attempt (via refresh token)",
			zap.Time("suspended_at", u.SuspendedAt.Time()),
			zap.Time("suspension_expires_at", u.SuspensionExpiresAt.Time()),
		)

		// since this user is suspended, then it's safe to assume
		// that this token is a liability and a possible threat,
		// and... is asking to be deleted
		if err = a.backend.DeleteRefreshToken(ctx, rtok); err != nil {
			l.Error(
				"USER SUSPENDED: failed to delete refresh token",
				zap.String("rtok_id", rtok.ID.String()),
				zap.Error(err),
			)

			return session, tpair, errors.Wrapf(err, "failed to delete refresh token: %s", rtok.ID)
		}

		return session, tpair, ErrUserSuspended
	}

	l.Debug("authenticated user by refresh token (rotated)")

	return session, tpair, nil
}

func (a *Authenticator) RefreshTokenByHash(
	ctx context.Context,
	hash Hash,
) (
	rt RefreshToken,
	err error,
) {
	if err = hash.Validate(); err != nil {
		return rt, err
	}

	return a.backend.RefreshTokenByHash(ctx, hash)
}

// CreateSession creates a new session for a given owner within the specified realm
func (a *Authenticator) CreateSession(
	ctx context.Context,
	issuer string,
	c *client.Client,
	ident Identity,
	flags SessionFlags,
	meta *RequestMetadata,
) (
	session *Session,
	authCode string,
	tpair TokenPair,
	err error,
) {
	// obtaining private key
	pk, err := a.PrivateKey()
	if err != nil {
		return session, "", tpair, errors.Wrap(err, "failed to obtain private key")
	}

	// TODO: add PKCE (use Token package, 1 checkin, 1 min expiry)

	// initializing new session
	session, err = NewSession(c, ident, meta, DefaultSessionTTL)
	if err != nil {
		return session, "", tpair, errors.Wrap(err, "failed to initialize new session")
	}

	// initializing new access token
	atok, err := NewTokenPair(ctx, pk, session.ID, issuer, ident, session.ExpireAt)
	if err != nil {
		return session, "", tpair, errors.Wrap(err, "failed to initialize new access token")
	}

	// adding session to the registry
	if err = a.SaveSession(ctx, session); err != nil {
		return session, "", tpair, errors.Wrap(err, "failed to register new session")
	}

	// safety measure
	defer func() {
		if err != nil {
			a.Logger().Error(
				"failed to delete faulty session",
				zap.String("session_id", session.ID.String()),
				zap.Error(err),
			)

			// deleting this session in case of any error at the end
			if _err := a.backend.DeleteSession(ctx, session); _err != nil {
				// wrapping error
				err = errors.Wrapf(err, "failed to delete faulty session: %s", session.ID)
			}
		}
	}()

	// generating a refresh token if an appropriate flag is set
	if flags&SFWithRefreshToken != 0 {
		// initializing new refresh token
		rtok, err := NewRefreshToken(session.ID, c, ident, session.ExpireAt)
		if err != nil {
			return session, "", tpair, errors.Wrap(err, "failed to generate refresh token for new session")
		}

		if err = a.backend.PutRefreshToken(ctx, rtok); err != nil {
			return session, "", tpair, errors.Wrap(err, "failed to store refresh token to backend")
		}
	}

	// generating new authorization code
	if flags&SFWithAuthorizationCode != 0 {
		authCode, err = util.NewCSPRNGHex(32)
		if err != nil {
			return session, "", tpair, errors.Wrap(err, "failed to generate authorization code")
		}

		// registering authorization code
		if err = a.backend.PutAuthCode(ctx, authCode, tpair); err != nil {
			return session, "", tpair, errors.Wrap(err, "failed to store authorization code")
		}
	}

	return session, authCode, tpair, nil
}

// RevokeSession revokes existing session instead of deleting,
// because previously issued access tokens are still out
// and can be used to re-generate a new session, thus it must
// be preserved until it eventually expires, and then deleted
// WARNING: session MUST NOT be deleted at least until it expires naturally
func (a *Authenticator) RevokeSession(ctx context.Context, session *Session, meta *RequestMetadata) (err error) {
	if session.IsRevoked() {
		return ErrSessionAlreadyRevoked
	}

	return nil
}

func (a *Authenticator) SaveSession(ctx context.Context, s *Session) (err error) {
	if err = s.Validate(); err != nil {
		return err
	}

	return a.backend.PutSession(ctx, s)
}

// SessionByID returns a session if it's found in the backend by its token string
func (a *Authenticator) SessionByID(ctx context.Context, jti uuid.UUID) (*Session, error) {
	return a.backend.SessionByID(ctx, jti)
}

func (a *Authenticator) RevokeRefreshToken(ctx context.Context, id uuid.UUID) (err error) {
	panic("not implemented")
}
