@startuml
namespace accesspolicy {
    class Actor << (S,Aquamarine) >> {
        + ID uuid.UUID
        + Kind ActorKind

    }
    class ActorKind << (S,Aquamarine) >> {
        + String() string

    }
    class Cell << (S,Aquamarine) >> {
        + Key Actor
        + Rights Right

    }
    class Manager << (S,Aquamarine) >> {
        - policies <font color=blue>map</font>[uuid.UUID]Policy
        - keyMap <font color=blue>map</font>[TKey]uuid.UUID
        - roster <font color=blue>map</font>[uuid.UUID]*Roster
        - groups *group.Manager
        - store Store
        - rosterLock sync.RWMutex

        - putPolicy(p Policy, r *Roster) error
        - lookupPolicy(id uuid.UUID) (Policy, error)
        - removePolicy(policyID uuid.UUID) error

        + Create(ctx context.Context, key TKey, ownerID uuid.UUID, parentID uuid.UUID, obj Object, flags uint8) (Policy, error)
        + Update(ctx context.Context, p Policy) error
        + PolicyByID(ctx context.Context, id uuid.UUID) (Policy, error)
        + PolicyByKey(ctx context.Context, name TKey) (Policy, error)
        + PolicyByObject(ctx context.Context, obj Object) (Policy, error)
        + DeletePolicy(ctx context.Context, p Policy) error
        + RosterByPolicyID(ctx context.Context, id uuid.UUID) (*Roster, error)
        + HasRights(ctx context.Context, pid uuid.UUID, actor Actor, rights Right) bool
        + GrantAccess(ctx context.Context, pid uuid.UUID, grantor Actor, grantee Actor, access Right) error
        + RevokeAccess(ctx context.Context, pid uuid.UUID, grantor Actor, grantee Actor) error
        + SetParent(ctx context.Context, policyID uuid.UUID, parentID uuid.UUID) error
        + Access(ctx context.Context, policyID uuid.UUID, userID uuid.UUID) Right
        + GroupAccess(ctx context.Context, pid uuid.UUID, groupID uuid.UUID) Right
        + GrantPublicAccess(ctx context.Context, pid uuid.UUID, grantor Actor, rights Right) error
        + GrantRoleAccess(ctx context.Context, pid uuid.UUID, grantor Actor, roleID uuid.UUID, rights Right) error
        + GrantGroupAccess(ctx context.Context, pid uuid.UUID, grantor Actor, groupID uuid.UUID, rights Right) error
        + GrantUserAccess(ctx context.Context, pid uuid.UUID, grantor Actor, userID uuid.UUID, rights Right) error
        + UserHasAccess(ctx context.Context, pid uuid.UUID, userID uuid.UUID, rights Right) bool
        + HasPublicRights(ctx context.Context, policyID uuid.UUID, rights Right) bool
        + HasGroupRights(ctx context.Context, policyID uuid.UUID, groupID uuid.UUID, rights Right) bool
        + HasRoleRights(ctx context.Context, policyID uuid.UUID, groupID uuid.UUID, rights Right) bool
        + SummarizedUserAccess(ctx context.Context, policyID uuid.UUID, userID uuid.UUID) Right

    }
    class Object << (S,Aquamarine) >> {
        + Name TObjectName
        + ID uuid.UUID

    }
    class Policy << (S,Aquamarine) >> {
        + Key TKey
        + ObjectName TObjectName
        + ID uuid.UUID
        + ParentID uuid.UUID
        + OwnerID uuid.UUID
        + ObjectID uuid.UUID
        + Flags uint8
        + _ <font color=blue>struct</font>{}

        + IsOwner(id uuid.UUID) bool
        + ApplyChangelog(changelog diff.Changelog) error
        + Validate() error
        + IsInherited() bool
        + IsExtended() bool
        + SetKey(key <font color=blue>interface</font>{}, maxLen int) error
        + SetObjectName(objectType <font color=blue>interface</font>{}, maxLen int) error

    }
    class PostgreSQLStore << (S,Aquamarine) >> {
        - db *pgx.Conn

        - withTransaction(ctx context.Context, fn <font color=blue>func</font>(*pgx.Tx) error) error
        - breakdownRoster(pid uuid.UUID, r *Roster) []RosterEntry
        - buildRoster(records []RosterEntry) *Roster
        - applyRosterChanges(tx *pgx.Tx, pid uuid.UUID, r *Roster) error
        - onePolicy(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) (Policy, error)
        - manyPolicies(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) ([]Policy, error)

        + CreatePolicy(ctx context.Context, p Policy, r *Roster) (Policy, *Roster, error)
        + UpdatePolicy(ctx context.Context, p Policy, r *Roster) error
        + FetchPolicyByID(ctx context.Context, id uuid.UUID) (Policy, error)
        + FetchPolicyByKey(ctx context.Context, key TKey) (Policy, error)
        + FetchPolicyByObject(ctx context.Context, obj Object) (Policy, error)
        + DeletePolicy(ctx context.Context, p Policy) error
        + CreateRoster(ctx context.Context, policyID uuid.UUID, r *Roster) error
        + FetchRosterByPolicyID(ctx context.Context, pid uuid.UUID) (*Roster, error)
        + UpdateRoster(ctx context.Context, pid uuid.UUID, r *Roster) error
        + DeleteRoster(ctx context.Context, pid uuid.UUID) error

    }
    class RAction << (S,Aquamarine) >> {
        + String() string

    }
    class Right << (S,Aquamarine) >> {
        + Translate() string
        + String() string

    }
    class Roster << (S,Aquamarine) >> {
        - calculatedCache <font color=blue>map</font>[Actor]Right
        - changes []rosterChange
        - registryLock sync.RWMutex
        - cacheLock sync.RWMutex
        - changeLock sync.RWMutex
        - backup *Roster

        + Registry []Cell
        + Everyone Right

        - put(key Actor, rights Right) 
        - lookup(key Actor) Right
        - hasRights(key Actor, rights Right) bool
        - delete(key Actor) 
        - putCache(key Actor, rights Right) 
        - lookupCache(key Actor) (Right, error)
        - deleteCache(key Actor) 
        - change(action RAction, key Actor, rights Right) 
        - clearChanges() 
        - createBackup() 
        - restoreBackup() 

    }
    class RosterEntry << (S,Aquamarine) >> {
        + PolicyID uuid.UUID
        + ActorID uuid.UUID
        + ActorKind ActorKind
        + Access Right
        + AccessExplained string

    }
    interface Store  {
        + CreatePolicy(ctx context.Context, p Policy, r *Roster) (Policy, *Roster, error)
        + UpdatePolicy(ctx context.Context, p Policy, r *Roster) error
        + FetchPolicyByID(ctx context.Context, id uuid.UUID) (Policy, error)
        + FetchPolicyByKey(ctx context.Context, key TKey) (Policy, error)
        + FetchPolicyByObject(ctx context.Context, obj Object) (Policy, error)
        + DeletePolicy(ctx context.Context, p Policy) error
        + CreateRoster(ctx context.Context, policyID uuid.UUID, r *Roster) error
        + FetchRosterByPolicyID(ctx context.Context, pid uuid.UUID) (*Roster, error)
        + UpdateRoster(ctx context.Context, pid uuid.UUID, r *Roster) error
        + DeleteRoster(ctx context.Context, pid uuid.UUID) error

    }
    class TKey << (S,Aquamarine) >> {
        + Value() (driver.Value, error)
        + Scan(v <font color=blue>interface</font>{}) error

    }
    class TObjectName << (S,Aquamarine) >> {
        + Value() (driver.Value, error)
        + Scan(v <font color=blue>interface</font>{}) error

    }
    class accesspolicy.ActorKind << (T, #FF7700) >>  {
    }
    class accesspolicy.RAction << (T, #FF7700) >>  {
    }
    class accesspolicy.Right << (T, #FF7700) >>  {
    }
    class accesspolicy.TKey << (T, #FF7700) >>  {
    }
    class rosterChange << (S,Aquamarine) >> {
        - action RAction
        - key Actor
        - accessRight Right

    }
}
"sync.RWMutex" *-- "accesspolicy.Manager"

"accesspolicy.Store" <|-- "accesspolicy.PostgreSQLStore"

"accesspolicy.Actor" o-- "accesspolicy.ActorKind"
"accesspolicy.Actor" o-- "uuid.UUID"
"accesspolicy.Cell" o-- "accesspolicy.Actor"
"accesspolicy.Cell" o-- "accesspolicy.Right"
"accesspolicy.Object" o-- "accesspolicy.TObjectName"
"accesspolicy.Object" o-- "uuid.UUID"
"accesspolicy.Policy" o-- "accesspolicy.TKey"
"accesspolicy.Policy" o-- "accesspolicy.TObjectName"
"accesspolicy.Policy" o-- "uuid.UUID"
"accesspolicy.Roster" o-- "accesspolicy.Cell"
"accesspolicy.Roster" o-- "accesspolicy.Right"
"accesspolicy.RosterEntry" o-- "accesspolicy.ActorKind"
"accesspolicy.RosterEntry" o-- "accesspolicy.Right"
"accesspolicy.RosterEntry" o-- "uuid.UUID"

namespace auth {
    class Authenticator << (S,Aquamarine) >> {
        - config Config
        - users *user.Manager
        - backend Backend
        - privateKey *rsa.PrivateKey
        - logger *zap.Logger

        + AccessTokenTTL time.Duration
        + RefreshTokenTTL time.Duration

        - claimsFromToken(tok string) (Claims, error)

        + SetLogger(logger *zap.Logger) error
        + Logger() *zap.Logger
        + UserManager() *user.Manager
        + GroupManager() *group.Manager
        + PasswordManager() password.Manager
        + TokenManager() *token.Manager
        + PrivateKey() (*rsa.PrivateKey, error)
        + Authenticate(ctx context.Context, username string, rawpass []byte, ri *RequestMetadata) (user.User, error)
        + AuthenticateByRefreshToken(ctx context.Context, t *token.Token, ri *RequestMetadata) (user.User, error)
        + DestroySession(ctx context.Context, destroyedByID uint32, stok string, ri *RequestMetadata) error
        + GenerateAccessToken(ctx context.Context, u user.User) (string, string, error)
        + GenerateRefreshToken(ctx context.Context, u user.User, ri *RequestMetadata) (*token.Token, error)
        + CreateSession(ctx context.Context, u user.User, ri *RequestMetadata, jti string, rtok *token.Token) (Session, error)
        + GenerateTokenTrinity(ctx context.Context, user user.User, ri *RequestMetadata) (*TokenTrinity, error)
        + UserIDFromToken(tok string) (uint32, error)
        + UserFromToken(ctx context.Context, tok string) (user.User, error)
        + RevokeAccessToken(id string, eat time.Time) error
        + IsRevoked(tokenID string) bool
        + RegisterSession(sess Session) error
        + GetSession(stok string) (Session, error)
        + GetSessionByAccessToken(jti string) (Session, error)
        + GetSessionBySessionToken(rtok string) (Session, error)

    }
    interface Backend  {
        + PutRevokedAccessToken( RevokedAccessToken) error
        + IsRevoked( string) bool
        + DeleteRevokedAccessItem( string) error
        + PutSession( Session) error
        + GetSession( string) (Session, error)
        + GetSessionByAccessToken( string) (Session, error)
        + GetSessionByRefreshToken( string) (Session, error)
        + DeleteSession( Session) error

    }
    class Claims << (S,Aquamarine) >> {
        + UserID uuid.UUID
        + Roles []group.TKey
        + Groups []group.TKey

    }
    class ClientCredentials << (S,Aquamarine) >> {
        + ClientID string
        + Secret string

    }
    class Config << (S,Aquamarine) >> {
        + CompareIP bool
        + CompareUserAgent bool

    }
    class Context << (S,Aquamarine) >> {
        + UserID uint32

    }
    class DefaultBackend << (S,Aquamarine) >> {
        - blacklist <font color=blue>map</font>[string]RevokedAccessToken
        - stokenMap <font color=blue>map</font>[string]Session
        - jtiMap <font color=blue>map</font>[string]Session
        - rtokenMap <font color=blue>map</font>[string]Session
        - sessions <font color=blue>map</font>[uint32]<font color=blue>map</font>[string]Session
        - hasWorker bool
        - workerInterval time.Duration

        - startWorker() error
        - cleanup() error

        + PutRevokedAccessToken(item RevokedAccessToken) error
        + IsRevoked(tokenID string) bool
        + DeleteRevokedAccessItem(tokenID string) error
        + PutSession(s Session) error
        + GetSession(stok string) (Session, error)
        + DeleteSession(sess Session) error
        + GetSessionByAccessToken(jti string) (Session, error)
        + GetSessionByRefreshToken(rtok string) (Session, error)

    }
    class Domain << (S,Aquamarine) >> {
        + String() string

    }
    class RefreshTokenPayload << (S,Aquamarine) >> {
        + UserID uint32
        + IP string
        + UserAgent string

    }
    class RequestMetadata << (S,Aquamarine) >> {
        + IP net.IP
        + UserAgent string

    }
    class RevokedAccessToken << (S,Aquamarine) >> {
        + TokenID string
        + ExpireAt time.Time

        + Validate() error

    }
    class Session << (S,Aquamarine) >> {
        + Token string
        + UserID uint32
        + IP string
        + UserAgent string
        + AccessTokenID string
        + RefreshToken string
        + ExpireAt time.Time
        + CreatedAt time.Time

        + Validate() error

    }
    class TokenTrinity << (S,Aquamarine) >> {
        + SessionToken string
        + AccessToken string
        + RefreshToken string

    }
    class UserCredentials << (S,Aquamarine) >> {
        + Username string
        + Password []byte

        + SanitizeAndValidate() error

    }
    class auth.ContextKey << (T, #FF7700) >>  {
    }
    class auth.Domain << (T, #FF7700) >>  {
    }
}
"jwt.StandardClaims" *-- "auth.Claims"
"auth.Domain" *-- "auth.Context"
"sync.RWMutex" *-- "auth.DefaultBackend"

"auth.Backend" <|-- "auth.DefaultBackend"

"auth.Authenticator" o-- "time.Duration"
"auth.Claims" o-- "group.TKey"
"auth.Claims" o-- "uuid.UUID"
"auth.RequestMetadata" o-- "net.IP"
"auth.RevokedAccessToken" o-- "time.Time"
"auth.Session" o-- "time.Time"

namespace bytearray {
    class ByteString128 << (S,Aquamarine) >> {
        + String() string
        + Trim() 
        + ToLower() 
        + EncodeBinary(ci *pgtype.ConnInfo, buf []byte) ([]byte, error)
        + DecodeBinary(ci *pgtype.ConnInfo, src []byte) error

    }
    class ByteString16 << (S,Aquamarine) >> {
        + String() string
        + Trim() 
        + ToLower() 
        + EncodeBinary(ci *pgtype.ConnInfo, buf []byte) ([]byte, error)
        + DecodeBinary(ci *pgtype.ConnInfo, src []byte) error

    }
    class ByteString256 << (S,Aquamarine) >> {
        + String() string
        + Trim() 
        + ToLower() 
        + EncodeBinary(ci *pgtype.ConnInfo, buf []byte) ([]byte, error)
        + DecodeBinary(ci *pgtype.ConnInfo, src []byte) error

    }
    class ByteString32 << (S,Aquamarine) >> {
        + String() string
        + Trim() 
        + ToLower() 
        + EncodeBinary(ci *pgtype.ConnInfo, buf []byte) ([]byte, error)
        + DecodeBinary(ci *pgtype.ConnInfo, src []byte) error

    }
    class ByteString512 << (S,Aquamarine) >> {
        + String() string
        + Trim() 
        + ToLower() 
        + EncodeBinary(ci *pgtype.ConnInfo, buf []byte) ([]byte, error)
        + DecodeBinary(ci *pgtype.ConnInfo, src []byte) error

    }
    class ByteString64 << (S,Aquamarine) >> {
        + String() string
        + Trim() 
        + ToLower() 
        + EncodeBinary(ci *pgtype.ConnInfo, buf []byte) ([]byte, error)
        + DecodeBinary(ci *pgtype.ConnInfo, src []byte) error

    }
    class bytearray.ByteString128 << (T, #FF7700) >>  {
    }
    class bytearray.ByteString16 << (T, #FF7700) >>  {
    }
    class bytearray.ByteString256 << (T, #FF7700) >>  {
    }
    class bytearray.ByteString32 << (T, #FF7700) >>  {
    }
    class bytearray.ByteString512 << (T, #FF7700) >>  {
    }
    class bytearray.ByteString64 << (T, #FF7700) >>  {
    }
}



namespace core {
    class Core << (S,Aquamarine) >> {
        - users *user.Manager
        - tokens *token.Manager
        - logger *zap.Logger

        + Init(ctx context.Context) error
        + UserManager() *user.Manager
        + TokenManager() (*token.Manager, error)
        + Validate() error
        + SetLogger(logger *zap.Logger) error
        + Logger() *zap.Logger
        + SetTokenManager(tm *token.Manager) error

    }
}



namespace endpoints {
    class Endpoint << (S,Aquamarine) >> {
        - name TName
        - core *core.Core
        - handler Handler

        + ServeHTTP(w http.ResponseWriter, r *http.Request) 

    }
    class Response << (S,Aquamarine) >> {
        + Error error
        + Result <font color=blue>interface</font>{}
        + ExecutionTime time.Duration

    }
    class TName << (S,Aquamarine) >> {
        + Scan(v <font color=blue>interface</font>{}) error
        + Value() (driver.Value, error)

    }
    class endpoints.ContextKey << (T, #FF7700) >>  {
    }
    class endpoints.Handler << (T, #FF7700) >>  {
    }
    class endpoints.TName << (T, #FF7700) >>  {
    }
    class "<font color=blue>func</font>(*core.Core, http.ResponseWriter, *http.Request) (<font color=blue>interface</font>{}, int, error)" as fontcolorbluefuncfontcoreCorehttpResponseWriterhttpRequestfontcolorblueinterfacefontinterror {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


"endpoints.Response" o-- "time.Duration"

namespace group {
    class Asset << (S,Aquamarine) >> {
        + Kind AssetKind
        + ID uuid.UUID

    }
    class AssetKind << (S,Aquamarine) >> {
        + Value() (driver.Value, error)
        + Scan(data []byte) error
        + String() string

    }
    class Flags << (S,Aquamarine) >> {
        + Translate() string
        + String() string
        + Value() (driver.Value, error)

    }
    class Group << (S,Aquamarine) >> {
        + DisplayName TName
        + Key TKey
        + ID uuid.UUID
        + ParentID uuid.UUID
        + Flags Flags
        + _ <font color=blue>struct</font>{}

        + Validate() error
        + IsDefault() bool
        + IsEnabled() bool
        + IsGroup() bool
        + IsRole() bool
        + SetKey(key <font color=blue>interface</font>{}, maxLen int) error
        + SetName(name <font color=blue>interface</font>{}, maxLen int) error

    }
    class Manager << (S,Aquamarine) >> {
        - groups <font color=blue>map</font>[uuid.UUID]Group
        - keyMap <font color=blue>map</font>[TKey]uuid.UUID
        - defaultIDs []uuid.UUID
        - assetGroups <font color=blue>map</font>[Asset][]uuid.UUID
        - groupAssets <font color=blue>map</font>[uuid.UUID][]Asset
        - store Store
        - logger *zap.Logger

        - setupDefaultGroups(ctx context.Context) error

        + SetLogger(logger *zap.Logger) error
        + Logger() *zap.Logger
        + Init(ctx context.Context) error
        + Store() (Store, error)
        + Create(ctx context.Context, flags Flags, parentID uuid.UUID, key TKey, name TName) (Group, error)
        + Put(ctx context.Context, g Group) error
        + Lookup(ctx context.Context, groupID uuid.UUID) (Group, error)
        + Remove(ctx context.Context, groupID uuid.UUID) error
        + List(kind Flags) []Group
        + GroupByID(ctx context.Context, id uuid.UUID) (Group, error)
        + GroupByKey(ctx context.Context, key TKey) (Group, error)
        + GroupByName(ctx context.Context, name TName) (Group, error)
        + DeleteGroup(ctx context.Context, groupID uuid.UUID) error
        + GroupsByAssetID(ctx context.Context, mask Flags, asset Asset) []Group
        + Groups(ctx context.Context, mask Flags) []Group
        + Parent(ctx context.Context, g Group) (Group, error)
        + Validate(ctx context.Context, groupID uuid.UUID) error
        + IsCircuited(ctx context.Context, groupID uuid.UUID) (bool, error)
        + SetParent(ctx context.Context, groupID uuid.UUID, newParentID uuid.UUID) error
        + IsAsset(ctx context.Context, groupID uuid.UUID, asset Asset) bool
        + CreateRelation(ctx context.Context, rel Relation) error
        + DeleteRelation(ctx context.Context, rel Relation) error
        + LinkAsset(ctx context.Context, groupID uuid.UUID, asset Asset) error
        + UnlinkAsset(ctx context.Context, groupID uuid.UUID, asset Asset) error
        + Invite(ctx context.Context, groupID uuid.UUID, asset Asset) error

    }
    class PostgreSQLStore << (S,Aquamarine) >> {
        - db *pgx.Conn

        - oneGroup(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) (Group, error)
        - manyGroups(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) ([]Group, error)
        - oneRelation(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) (Relation, error)
        - manyRelations(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) ([]Relation, error)

        + UpsertGroup(ctx context.Context, g Group) (Group, error)
        + CreateRelation(ctx context.Context, rel Relation) error
        + FetchGroupByID(ctx context.Context, groupID uuid.UUID) (Group, error)
        + FetchGroupByKey(ctx context.Context, key TKey) (Group, error)
        + FetchGroupByName(ctx context.Context, name TName) (Group, error)
        + FetchGroupsByName(ctx context.Context, isPartial bool, name TName) ([]Group, error)
        + FetchAllGroups(ctx context.Context) ([]Group, error)
        + FetchAllRelations(ctx context.Context) ([]Relation, error)
        + FetchGroupRelations(ctx context.Context, groupID uuid.UUID) ([]Relation, error)
        + HasRelation(ctx context.Context, rel Relation) (bool, error)
        + DeleteByID(ctx context.Context, groupID uuid.UUID) error
        + DeleteRelation(ctx context.Context, rel Relation) error

    }
    class Relation << (S,Aquamarine) >> {
        + GroupID uuid.UUID
        + Asset Asset

    }
    interface Store  {
        + UpsertGroup(ctx context.Context, g Group) (Group, error)
        + CreateRelation(ctx context.Context, rel Relation) error
        + FetchGroupByID(ctx context.Context, groupID uuid.UUID) (Group, error)
        + FetchGroupByKey(ctx context.Context, key TKey) (Group, error)
        + FetchGroupByName(ctx context.Context, name TName) (Group, error)
        + FetchGroupsByName(ctx context.Context, isPartial bool, name TName) ([]Group, error)
        + HasRelation(ctx context.Context, rel Relation) (bool, error)
        + FetchAllGroups(ctx context.Context) ([]Group, error)
        + FetchAllRelations(ctx context.Context) ([]Relation, error)
        + FetchGroupRelations(ctx context.Context, groupID uuid.UUID) ([]Relation, error)
        + DeleteByID(ctx context.Context, groupID uuid.UUID) error
        + DeleteRelation(ctx context.Context, rel Relation) error

    }
    class TKey << (S,Aquamarine) >> {
        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(data []byte) ([]byte, error)
        + Value() (driver.Value, error)
        + EncodeBinary(ci *pgtype.ConnInfo, buf []byte) ([]byte, error)
        + Scan(v <font color=blue>interface</font>{}) error
        + String() string

    }
    class TName << (S,Aquamarine) >> {
        + Value() (driver.Value, error)
        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(data []byte) ([]byte, error)
        + String() string
        + Scan(v <font color=blue>interface</font>{}) error

    }
    class group.AssetKind << (T, #FF7700) >>  {
    }
    class group.Flags << (T, #FF7700) >>  {
    }
    class group.List << (T, #FF7700) >>  {
    }
    class group.TKey << (T, #FF7700) >>  {
    }
}
"sync.RWMutex" *-- "group.Manager"

"group.Store" <|-- "group.PostgreSQLStore"

"group.Asset" o-- "group.AssetKind"
"group.Asset" o-- "uuid.UUID"
"group.Group" o-- "group.Flags"
"group.Group" o-- "group.TKey"
"group.Group" o-- "group.TName"
"group.Group" o-- "uuid.UUID"
"group.Relation" o-- "group.Asset"
"group.Relation" o-- "uuid.UUID"

namespace guard {
    class cache << (S,Aquamarine) >> {
        - objects <font color=blue>map</font>[string]object

        - inspectObject(obj <font color=blue>interface</font>{}) (object, error)

    }
    class object << (S,Aquamarine) >> {
        - name string
        - dbColumns <font color=blue>map</font>[string]string
        - editable <font color=blue>map</font>[string]bool

        - addFields(field reflect.StructField) 

    }
}
"sync.RWMutex" *-- "guard.cache"



namespace password {
    interface Manager  {
        + Upsert(ctx context.Context, p Password) error
        + Get(ctx context.Context, kind Kind, ownerID uuid.UUID) (Password, error)
        + Delete(ctx context.Context, kind Kind, ownerID uuid.UUID) error

    }
    class Password << (S,Aquamarine) >> {
        + Kind Kind
        + OwnerID uuid.UUID
        + Hash []byte
        + CreatedAt uint32
        + UpdatedAt uint32
        + ExpireAt uint32
        + IsChangeRequired bool

        + Validate() error
        + Compare(rawpass []byte) bool

    }
    class PostgreSQLStore << (S,Aquamarine) >> {
        - db *pgx.Conn

        + Upsert(ctx context.Context, p Password) error
        + Get(ctx context.Context, kind Kind, ownerID uuid.UUID) (Password, error)
        + Delete(ctx context.Context, kind Kind, ownerID uuid.UUID) error

    }
    interface Store  {
        + Upsert(ctx context.Context, p Password) error
        + Get(ctx context.Context, k Kind, ownerID uuid.UUID) (Password, error)
        + Delete(ctx context.Context, k Kind, ownerID uuid.UUID) error

    }
    class defaultManager << (S,Aquamarine) >> {
        - store Store

        + Upsert(ctx context.Context, p Password) error
        + Get(ctx context.Context, kind Kind, ownerID uuid.UUID) (Password, error)
        + Delete(ctx context.Context, k Kind, ownerID uuid.UUID) error

    }
    class password.Kind << (T, #FF7700) >>  {
    }
}

"password.Manager" <|-- "password.PostgreSQLStore"
"password.Store" <|-- "password.PostgreSQLStore"
"password.Manager" <|-- "password.defaultManager"
"password.Store" <|-- "password.defaultManager"

"password.Password" o-- "password.Kind"
"password.Password" o-- "uuid.UUID"

namespace server {
    class Response << (S,Aquamarine) >> {
        + StatusCode int
        + Error error
        + Payload <font color=blue>interface</font>{}

    }
    class Server << (S,Aquamarine) >> {
        - core *core.Core

    }
    class server.ContextKey << (T, #FF7700) >>  {
    }
}



namespace task {
    class Manager << (S,Aquamarine) >> {
    }
    class Queue << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class Status << (S,Aquamarine) >> {
        + Total int64
        + Current int64
        + StageTotal int64
        + StageCurrent int64
        + Flags uint64

    }
    class Task << (S,Aquamarine) >> {
        - fn Process

        + Name string
        + StartedAt dbr.NullTime
        + ExecTime dbr.NullTime

    }
    class task.Process << (T, #FF7700) >>  {
    }
    class task.Queue << (T, #FF7700) >>  {
    }
}


"task.Task" o-- "dbr.NullTime"

namespace token {
    class Callback << (S,Aquamarine) >> {
        + Name CallbackName
        + Kind Kind
        + Function <font color=blue>func</font>(context.Context, Token) error

    }
    class CallbackError << (S,Aquamarine) >> {
        + Kind Kind
        + Token Token
        + Err error

    }
    class CallbackName << (S,Aquamarine) >> {
        + Scan(data <font color=blue>interface</font>{}) error
        + Value() (driver.Value, error)

    }
    class Hash << (S,Aquamarine) >> {
        + EncodeBinary(ci *pgtype.ConnInfo, buf []byte) ([]byte, error)
        + DecodeBinary(ci *pgtype.ConnInfo, src []byte) error
        + String() string

    }
    class Kind << (S,Aquamarine) >> {
        + String() string

    }
    class Manager << (S,Aquamarine) >> {
        - tokens <font color=blue>map</font>[Hash]Token
        - store Store
        - callbacks []Callback
        - errorChan <font color=blue>chan</font> CallbackError
        - logger *zap.Logger

        + BaseContext context.Context

        + SetLogger(logger *zap.Logger) error
        + Logger() *zap.Logger
        + Init() error
        + Store() (Store, error)
        + Validate() error
        + List(k Kind) []Token
        + Create(ctx context.Context, k Kind, ttl time.Duration, checkins int32) (Token, error)
        + Get(ctx context.Context, hash Hash) (Token, error)
        + Delete(ctx context.Context, t Token) error
        + Checkin(ctx context.Context, hash Hash) error
        + Cleanup(ctx context.Context) error
        + AddCallback(kind Kind, name CallbackName, fn <font color=blue>func</font>(context.Context, Token) error) error
        + GetCallback(name CallbackName) (*Callback, error)
        + GetCallbacks(k Kind) []Callback
        + RemoveCallback(name CallbackName) error

    }
    interface Store  {
        + Put(ctx context.Context, t Token) error
        + Get(ctx context.Context, hash Hash) (Token, error)
        + Delete(ctx context.Context, hash Hash) error

    }
    class Token << (S,Aquamarine) >> {
        + Kind Kind
        + Hash Hash
        + CheckinTotal int32
        + CheckinRemainder int32
        + CreatedAt int64
        + ExpireAt int64

        + Validate() error

    }
    class defaultTokenStore << (S,Aquamarine) >> {
        - db *pgx.Conn

        + Put(ctx context.Context, t Token) error
        + Get(ctx context.Context, hash Hash) (Token, error)
        + Delete(ctx context.Context, hash Hash) error

    }
    class token.CallbackName << (T, #FF7700) >>  {
    }
    class token.Hash << (T, #FF7700) >>  {
    }
    class token.Kind << (T, #FF7700) >>  {
    }
}
"sync.RWMutex" *-- "token.Manager"

"token.Store" <|-- "token.defaultTokenStore"

"token.Callback" o-- "token.CallbackName"
"token.Callback" o-- "token.Kind"
"token.CallbackError" o-- "token.Kind"
"token.CallbackError" o-- "token.Token"
"token.Manager" o-- "context.Context"
"token.Token" o-- "token.Hash"
"token.Token" o-- "token.Kind"

namespace user {
    class Container << (S,Aquamarine) >> {
        + Validate() error
        + Filter(fn <font color=blue>func</font>(User) bool) Container

    }
    class Email << (S,Aquamarine) >> {
        + UserID uuid.UUID

        + Validate() error
        + ApplyChangelog(changelog diff.Changelog) error

    }
    class EmailEssential << (S,Aquamarine) >> {
        + Addr bytearray.ByteString256
        + IsPrimary bool

    }
    class EmailMetadata << (S,Aquamarine) >> {
        - keyHash uint64

        + CreatedAt uint32
        + ConfirmedAt uint32
        + UpdatedAt uint32

    }
    class Essential << (S,Aquamarine) >> {
        + Username bytearray.ByteString32
        + DisplayName bytearray.ByteString32

    }
    class IPAddr << (S,Aquamarine) >> {
        + EncodeBinary(ci *pgtype.ConnInfo, buf []byte) ([]byte, error)
        + DecodeBinary(ci *pgtype.ConnInfo, src []byte) error
        + StringIPv4() string

    }
    class Manager << (S,Aquamarine) >> {
        - passwords password.Manager
        - groups *group.Manager
        - policies *accesspolicy.Manager
        - tokens *token.Manager
        - store Store
        - logger *zap.Logger

        + CreateEmail(ctx context.Context, fn <font color=blue>func</font>(context.Context) (NewEmailObject, error)) (Email, error)
        + EmailByAddr(ctx context.Context, addr bytearray.ByteString256) (Email, error)
        + PrimaryEmailByUserID(ctx context.Context, userID uuid.UUID) (Email, error)
        + UpdateEmail(ctx context.Context, addr bytearray.ByteString256, fn <font color=blue>func</font>(context.Context, Email) (Email, error)) (Email, diff.Changelog, error)
        + DeleteEmailByAddr(ctx context.Context, userID uuid.UUID, addr bytearray.ByteString256) error
        + ConfirmEmail(ctx context.Context, addr bytearray.ByteString256) error
        + Validate() error
        + Store() (Store, error)
        + SetLogger(logger *zap.Logger) error
        + Logger() *zap.Logger
        + SetPasswordManager(pm password.Manager) error
        + SetGroupManager(gm *group.Manager) error
        + SetTokenManager(tm *token.Manager) error
        + SetAccessPolicyManager(apm *accesspolicy.Manager) error
        + GroupManager() *group.Manager
        + AccessPolicyManager() *accesspolicy.Manager
        + TokenManager() *token.Manager
        + PasswordManager() password.Manager
        + CreatePhone(ctx context.Context, fn <font color=blue>func</font>(context.Context) (NewPhoneObject, error)) (Phone, error)
        + PrimaryPhoneByUserID(ctx context.Context, userID uuid.UUID) (Phone, error)
        + UpdatePhone(ctx context.Context, number bytearray.ByteString16, fn <font color=blue>func</font>(context.Context, Phone) (Phone, error)) (Phone, diff.Changelog, error)
        + DeletePhoneByNumber(ctx context.Context, userID uuid.UUID, number bytearray.ByteString16) (Phone, error)
        + CreateProfile(ctx context.Context, fn <font color=blue>func</font>(context.Context) (NewProfileObject, error)) (Profile, error)
        + GetProfileByID(ctx context.Context, id uuid.UUID) (Profile, error)
        + UpdateProfile(ctx context.Context, id uuid.UUID, fn <font color=blue>func</font>(context.Context, Profile) (Profile, error)) (Profile, diff.Changelog, error)
        + DeleteProfileByUserID(ctx context.Context, userID uuid.UUID) error
        + CreateUser(ctx context.Context, fn <font color=blue>func</font>(context.Context) (NewUserObject, error)) (User, error)
        + BulkCreateUser(ctx context.Context, newUsers []User) ([]User, error)
        + UserByID(ctx context.Context, id uuid.UUID) (User, error)
        + UserByUsername(ctx context.Context, username string) (User, error)
        + UserByEmailAddr(ctx context.Context, addr string) (User, error)
        + UpdateUser(ctx context.Context, id uuid.UUID, fn <font color=blue>func</font>(context.Context, User) (User, error)) (User, diff.Changelog, error)
        + DeleteUserByID(ctx context.Context, id uuid.UUID, isHard bool) (User, error)
        + CheckAvailability(ctx context.Context, username string, email string) error
        + SetPassword(ctx context.Context, userID uuid.UUID, p password.Password) error

    }
    class Metadata << (S,Aquamarine) >> {
        + Checksum uint64
        + CreatedAt uint32
        + CreatedByID uuid.UUID
        + UpdatedAt uint32
        + UpdatedByID uuid.UUID
        + ConfirmedAt uint32
        + DeletedAt uint32
        + DeletedByID uuid.UUID
        + LastLoginAt uint32
        + LastLoginIP IPAddr
        + LastLoginFailedAt uint32
        + LastLoginFailedIP IPAddr
        + LastLoginAttempts uint8
        + IsSuspended bool
        + SuspendedAt uint32
        + SuspensionExpiresAt uint32
        + SuspensionReason bytearray.ByteString128

    }
    class NewEmailObject << (S,Aquamarine) >> {
        + UserID uuid.UUID
        + IsConfirmed bool

    }
    class NewPhoneObject << (S,Aquamarine) >> {
        + UserID uuid.UUID
        + IsConfirmed bool

    }
    class NewProfileObject << (S,Aquamarine) >> {
        + UserID uuid.UUID

    }
    class NewUserObject << (S,Aquamarine) >> {
        + EmailAddr bytearray.ByteString256
        + PhoneNumber bytearray.ByteString16
        + Password []byte

    }
    interface Object  {
        + ObjectID() int64
        + ObjectKind() uint8

    }
    class Phone << (S,Aquamarine) >> {
        + UserID uuid.UUID

        + Validate() error
        + ApplyChangelog(changelog diff.Changelog) error

    }
    class PhoneEssential << (S,Aquamarine) >> {
        + Number bytearray.ByteString16
        + IsPrimary bool

    }
    class PhoneMetadata << (S,Aquamarine) >> {
        - keyHash uint64

        + CreatedAt uint32
        + ConfirmedAt uint32
        + UpdatedAt uint32

    }
    class PostgreSQLStore << (S,Aquamarine) >> {
        - db *pgx.Conn

        - oneEmail(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) (Email, error)
        - manyEmails(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) ([]Email, error)
        - onePhone(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) (Phone, error)
        - manyPhones(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) ([]Phone, error)
        - fetchUserByQuery(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) (User, error)
        - fetchUsersByQuery(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) ([]User, error)

        + UpsertEmail(ctx context.Context, e Email) (Email, error)
        + FetchPrimaryEmailByUserID(ctx context.Context, userID uuid.UUID) (Email, error)
        + FetchEmailsByUserID(ctx context.Context, userID uuid.UUID) ([]Email, error)
        + FetchEmailByAddr(ctx context.Context, addr string) (Email, error)
        + DeleteEmailByAddr(ctx context.Context, userID uuid.UUID, addr string) error
        + UpsertPhone(ctx context.Context, e Phone) (Phone, error)
        + FetchPrimaryPhoneByUserID(ctx context.Context, userID uuid.UUID) (Phone, error)
        + FetchPhonesByUserID(ctx context.Context, userID uuid.UUID) ([]Phone, error)
        + FetchPhoneByAddr(ctx context.Context, number string) (Phone, error)
        + DeletePhoneByAddr(ctx context.Context, userID uuid.UUID, number string) error
        + UpsertProfile(ctx context.Context, e Phone) (Phone, error)
        + FetchProfileByUserID(ctx context.Context, userID uuid.UUID) (Profile, error)
        + DeleteProfileByUserID(ctx context.Context, userID uuid.UUID) error
        + CreateUser(ctx context.Context, u User) (User, error)
        + BulkCreateUser(ctx context.Context, us []User) ([]User, error)
        + FetchUserByID(ctx context.Context, id uint32) (User, error)
        + FetchUserByUsername(ctx context.Context, username string) (User, error)
        + FetchUserByEmailAddr(ctx context.Context, addr string) (User, error)
        + FetchUserByPhoneNumber(ctx context.Context, number string) (User, error)
        + UpdateUser(ctx context.Context, u User, changelog diff.Changelog) (User, error)
        + DeleteUserByID(ctx context.Context, id uint32) error
        + DeleteUsersByQuery(ctx context.Context, q string, args ...<font color=blue>interface</font>{}) error

    }
    class Profile << (S,Aquamarine) >> {
        + UserID uuid.UUID

        - calculateChecksum() uint64

        + Validate() error
        + ApplyChangelog(changelog diff.Changelog) error

    }
    class ProfileEssential << (S,Aquamarine) >> {
        + Firstname bytearray.ByteString16
        + Lastname bytearray.ByteString16
        + Middlename bytearray.ByteString16
        + Language []byte

    }
    class ProfileMetadata << (S,Aquamarine) >> {
        - keyHash uint64

        + Checksum uint64
        + CreatedAt dbr.NullTime
        + UpdatedAt dbr.NullTime

    }
    interface Store  {
        + UpsertUser(ctx context.Context, u User) (User, error)
        + FetchUserByID(ctx context.Context, id uuid.UUID) (User, error)
        + FetchUserByUsername(ctx context.Context, username bytearray.ByteString32) (User, error)
        + FetchUserByEmailAddr(ctx context.Context, addr bytearray.ByteString256) (User, error)
        + FetchUserByPhoneNumber(ctx context.Context, number bytearray.ByteString16) (User, error)
        + DeleteUserByID(ctx context.Context, id uuid.UUID) error
        + UpsertEmail(ctx context.Context, e Email) (Email, error)
        + FetchPrimaryEmailByUserID(ctx context.Context, userID uuid.UUID) (Email, error)
        + FetchEmailByAddr(ctx context.Context, addr bytearray.ByteString256) (Email, error)
        + FetchEmailsByUserID(ctx context.Context, userID uuid.UUID) ([]Email, error)
        + DeleteEmailByAddr(ctx context.Context, userID uuid.UUID, addr bytearray.ByteString256) error
        + UpsertPhone(ctx context.Context, p Phone) (Phone, error)
        + FetchPrimaryPhoneByUserID(ctx context.Context, userID uuid.UUID) (Phone, error)
        + FetchPhoneByNumber(ctx context.Context, number bytearray.ByteString16) (Phone, error)
        + FetchPhonesByUserID(ctx context.Context, userID uuid.UUID) ([]Phone, error)
        + DeletePhoneByNumber(ctx context.Context, userID uuid.UUID, number bytearray.ByteString16) error
        + UpsertProfile(ctx context.Context, p Profile) (Profile, error)
        + FetchProfileByUserID(ctx context.Context, userID uuid.UUID) (Profile, error)
        + DeleteProfileByUserID(ctx context.Context, userID uuid.UUID) error

    }
    class Team << (S,Aquamarine) >> {
    }
    class User << (S,Aquamarine) >> {
        - keyHash uint64

        + ID uuid.UUID
        + ULID ulid.ULID

        - calculateChecksum() uint64

        + ApplyChangelog(changelog diff.Changelog) error
        + StringID() string
        + Validate() error

    }
    class user.Container << (T, #FF7700) >>  {
    }
    class user.ContextKey << (T, #FF7700) >>  {
    }
    class user.IPAddr << (T, #FF7700) >>  {
    }
}
"user.EmailEssential" *-- "user.Email"
"user.EmailMetadata" *-- "user.Email"
"sync.RWMutex" *-- "user.Manager"
"user.EmailEssential" *-- "user.NewEmailObject"
"user.PhoneEssential" *-- "user.NewPhoneObject"
"user.ProfileEssential" *-- "user.NewProfileObject"
"user.Essential" *-- "user.NewUserObject"
"user.ProfileEssential" *-- "user.NewUserObject"
"user.PhoneEssential" *-- "user.Phone"
"user.PhoneMetadata" *-- "user.Phone"
"user.ProfileEssential" *-- "user.Profile"
"user.ProfileMetadata" *-- "user.Profile"
"user.Essential" *-- "user.User"
"user.Metadata" *-- "user.User"


"user.Email" o-- "uuid.UUID"
"user.EmailEssential" o-- "bytearray.ByteString256"
"user.Essential" o-- "bytearray.ByteString32"
"user.Metadata" o-- "bytearray.ByteString128"
"user.Metadata" o-- "user.IPAddr"
"user.Metadata" o-- "uuid.UUID"
"user.NewEmailObject" o-- "uuid.UUID"
"user.NewPhoneObject" o-- "uuid.UUID"
"user.NewProfileObject" o-- "uuid.UUID"
"user.NewUserObject" o-- "bytearray.ByteString16"
"user.NewUserObject" o-- "bytearray.ByteString256"
"user.Phone" o-- "uuid.UUID"
"user.PhoneEssential" o-- "bytearray.ByteString16"
"user.Profile" o-- "uuid.UUID"
"user.ProfileEssential" o-- "bytearray.ByteString16"
"user.ProfileMetadata" o-- "dbr.NullTime"
"user.User" o-- "ulid.ULID"
"user.User" o-- "uuid.UUID"

namespace util {
    class HTTPError << (S,Aquamarine) >> {
        + Scope string
        + Key string
        + Message string
        + Code int

    }
    class work << (S,Aquamarine) >> {
        - kind string
        - payload []byte
        - result <font color=blue>chan</font> <font color=blue>interface</font>{}

    }
}



"__builtin__.[]byte" #.. "accesspolicy.TKey"
"__builtin__.[]byte" #.. "bytearray.ByteString128"
"__builtin__.[]byte" #.. "bytearray.ByteString16"
"__builtin__.[]byte" #.. "bytearray.ByteString256"
"__builtin__.[]byte" #.. "bytearray.ByteString32"
"__builtin__.[]byte" #.. "bytearray.ByteString512"
"__builtin__.[]byte" #.. "bytearray.ByteString64"
"__builtin__.[]byte" #.. "endpoints.TName"
"__builtin__.[]byte" #.. "group.TKey"
"__builtin__.[]byte" #.. "token.CallbackName"
"__builtin__.[]byte" #.. "token.Hash"
"__builtin__.[]byte" #.. "user.IPAddr"
"__builtin__.int" #.. "endpoints.ContextKey"
"__builtin__.uint16" #.. "token.Kind"
"__builtin__.uint16" #.. "user.ContextKey"
"__builtin__.uint32" #.. "accesspolicy.Right"
"__builtin__.uint8" #.. "accesspolicy.ActorKind"
"__builtin__.uint8" #.. "accesspolicy.RAction"
"__builtin__.uint8" #.. "auth.ContextKey"
"__builtin__.uint8" #.. "auth.Domain"
"__builtin__.uint8" #.. "group.AssetKind"
"__builtin__.uint8" #.. "group.Flags"
"__builtin__.uint8" #.. "password.Kind"
"__builtin__.uint8" #.. "server.ContextKey"
"endpoints.fontcolorbluefuncfontcoreCorehttpResponseWriterhttpRequestfontcolorblueinterfacefontinterror" #.. "endpoints.Handler"
"group.[]Group" #.. "group.List"
"task.<font color=blue>func</font>() (<font color=blue>chan</font> Status, error)" #.. "task.Process"
"task.[]Task" #.. "task.Queue"
"user.[]User" #.. "user.Container"
@enduml
